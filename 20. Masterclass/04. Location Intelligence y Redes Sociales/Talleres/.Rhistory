n.ahead=12,
newxreg=calendarioMasOutliersTest))
datos.pred.auto <- data.frame(FECHA = datos.test$FECHA,
Prediccion.auto = exp(prediccion.auto$pred + 0.5 * prediccion.auto$se^2))
datos.real.pred.auto <- merge(datos.real.pred, datos.pred.auto, by = "FECHA", all.x = T)
grafico <- ggplot(data = datos.real.pred.auto) +
geom_line(aes(x= FECHA, y = REAL), color = 'blue',
alpha = 0.4, size = 0.8) +
geom_line(aes(x= FECHA, y = TARGET), color = 'blue',
alpha = 0.8, size = 0.8) +
geom_line(aes(x= FECHA, y = Prediccion), color = 'darkred',
size = 1)   +
geom_line(aes(x= FECHA, y = Prediccion.auto), color = 'orange',
size = 1) +
xlab('FECHA') + ylab('Matriculaciones') + ggtitle('Ajuste Manual vs Ajuste Automático')
ggplotly(grafico)
#'   ioslides_presentation:
#'     logo: ./img/afi.png
#'     smaller: yes
#'     widescreen: yes
#'     toc: true
#'     toc_depth: 2
#'   beamer_presentation: default
#' ---
#'
#'
knitr::opts_chunk$set(cache=T,fig.align='center',message=FALSE,warning=FALSE)
rm(list = ls());gc()
setwd("C:/Users/Javier/Mis documentos/masterAFI/20. Masterclass/04. Location Intelligence y Redes Sociales/Talleres/")
library(RgoogleMaps)
library(ggmap)
library(rgdal)
library(leaflet)
library(lubridate)
library(dplyr)
library(raster)
library(sf)
#' </div>
#'
#' ## Usando raster data
#'
#' En `R` hay muchos paquetes para descargar, tratar y analizar imagenes geográficas tipo raster. Empecemos con los que se descargan imágenes.
#'
#' Básicamente estos paquetes descargan una imagen (raster) de un mapa y permiten mostrar sobre estos mapas puntos, líneas, polígonos, etc.
#'
#' Antes de pintar el mapa, vamos a bajarnos algunos puntos geolocalizados. En concreto los centros comerciales en la comunidad de Madrid (http://www.madrid.org/nomecalles/)
#'
centros <- read.table("./data/centros_comerciales.csv",header=T,stringsAsFactors = F)
head(centros,2)
#'
#' Como vemos los centros comerciales vienen georeferenciados con coordenadas lat lon
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Pintamos el mapa de Madrid con los puntos de los centros comerciales. Primero lo hacemos con el paquete  `RgoogleMaps` que toma los mapas de Google
#'
require(RgoogleMaps)
MadridMap <- GetMap(center = c(40.415364,-3.707398), zoom = 11,maptype="mobile")
tmp <- PlotOnStaticMap(MadridMap,lon=centros$lon,lat=centros$lat,pch=20,cex=2,col=factor(centros$ETIQUETA))
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos cambiar el tipo de mapa para mostrar diferentes tipos de imágenes `maptype = c("roadmap", "mobile", "satellite", "terrain", "hybrid", "mapmaker-roadmap", "mapmaker-hybrid")
#'
#'
MadridMap <- GetMap(center = c(40.415364,-3.707398), zoom = 11,maptype="hybrid")
tmp <- PlotOnStaticMap(MadridMap,lon=centros$lon,lat=centros$lat,pch=20,cex=2,col=factor(centros$ETIQUETA))
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Lo mismo lo podemos hacer con el paquete `ggmap` (https://github.com/dkahle/ggmap). Y un poco más fácil.
#'
require(ggmap)
madrid_bb <- c(-3.933449,40.290525,-3.476830,40.538069)
mm <- get_stamenmap(madrid_bb,zoom=11)
ggmap(mm)+geom_point(data=centros, aes(x=lon,y=lat,col=ETIQUETA))
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA))
m
View(centros)
columns(centros)
colnames(centros)
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA))
m
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA))
ggmap(mm)+geom_point(data=centros, aes(x=lon,y=lat,col=ETIQUETA))
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA))
m
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lat, ~lon, popup = ~ as.character(ETIQUETA))
m
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA))
m
#'
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Podemos hacer esto con visualización interactiva a través del paquete `leaflet` https://rstudio.github.io/leaflet/ Los mapas por defecto son de OpenStreetMap
#'
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat)
m
#'
#'
#' ## Paquetes con integración con APIs de mapas
#'
#' Aunque podemos también cambiar el tipo de mapas con los que trabajamos si le especificamos de dónde puede sacar los `tiles`
#'
m <- leaflet(data=centros) %>%
addTiles() %>%
addMarkers(~lon, ~lat, popup = ~ as.character(ETIQUETA)) %>%
addProviderTiles(providers$CartoDB.Positron)
m
#' - Shapefiles para los municipios de España<br> http://www.ine.es/censos2011_datos/cartografia_censo2011_nacional.zip
#' - Shapefiles para diferentes países a diferentes resoluciones administrativas<br> http://http://www.gadm.org
#' - Shapefiles para los barrios/distritos de Madrid http://www.madrid.org/nomecalles/DescargaBDTCorte.icm
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Hay muchos paquetes para trabajar con objetos geográficos en `R`. Los más importantes que vamos a ver son `rgdal` y `sp`. Por ejemplo, vamos a bajarnos los shapefiles de los barrios de Madrid y los visualizamos. Para cargar los shapefiles vamos a utilizar el paquete `rgdal` package
#'
#'
par(mar=c(0,0,0,0))
require(sf)
map_barrios <- read_sf("./data/Barrios Madrid/200001469.shp")
map_barrios$DESBDT <- iconv(map_barrios$DESBDT,from="Windows-1252", to="UTF-8")
plot(map_barrios)
#'
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Cuando cargamos un shapefile en `R` con `sf` una de las columnas de la tabla son los polígonos. Es importante también comprobar la proyección utilizada:
#'
head(map_barrios,3)
st_crs(map_barrios)
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Hay muchas funciones para trabajar, analizar y modificar estos objetos. Por ejemplo
#'
dim(map_barrios) # nos dice cuantas `features` hay. En este caso polígonos
st_area(map_barrios) # nos da el área de cada uno de los polígonos
#'
#'
#' Por otro lado `st_centroid(map_barrios)` nos devuelve las coordenadas de los centros de cada polígono
#'
#'
cc <- st_centroid(map_barrios)
head(st_geometry(cc),2)
#'
#' Como vemos las coordenadas no están en lat, lon. Eso es debido a que el mapa utiliza una proyección de datos geográficos diferente a la habitual
#'
#'
st_crs(map_barrios)
#' )
#'
#'
#' </div>
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Vamos a cambiar la proyección UTM que tiene nuestro shapefile a uno con WGS84
#'
#'
mapb <- st_transform(map_barrios,"+proj=longlat +datum=WGS84")
mapb <- st_transform(map_barrios,4326)
#'
#'
#' y ahora como vemos las coordenadas están en longitud/latitud
#'
#'
cc <- st_centroid(mapb)
head(st_geometry(mapb),2)
#'
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Podemos visualizar todos los polígonos o solo parte de ellos
#'
par(mfrow=c(1,2))
plot(mapb["DESBDT"])
plot(mapb[mapb$DESBDT %in% c("011 Palacio","015 Universidad"),"DESBDT"])
#'
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Podemos poner juntos imágenes raster con puntos (ya lo hemos visto) y también los polígonos. Por ejemplo, usando `ggmap` podemos poner los polígonos de los distritos de Madrid encima de un mapa raster. Para ello tenemos que convertir el objeto `SpatialDataFrame` a un `data.frame`utilizando el comando fortify
#'
#'
ggmap(mm)+geom_sf(data=mapb,inherit.aes = F,fill="grey",size=.2,alpha=.5,color="green")
#'
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Lo mismo podemos hacer con leaflet
#'
#'
leaflet(mapb) %>% addTiles() %>% addPolygons(weight=2,color="green",fillColor="gray",fillOpacity = 0.5)
#'
#'
#' ## Paquetes para trabajar con objetos geográficos
#'
#' Con leaflet es muy facil también mostrar diferentes capas. Por ejemplo vamos a mostrar los distritos y los centros comerciales
#'
#'
leaflet(mapb) %>% addTiles() %>%
addPolygons(weight=2,color="green",fillColor="gray",fillOpacity = 0.5) %>%
addCircles(data=centros, lng= ~lon, lat=~lat,popup = ~ ETIQUETA)
#'
#'
#'
#'
#' ## Choropleths
#'
#' Una de las visualizacións de información geográfica más utilizada es dibujar los polígonos con colores proporcionales a una variable (choropleths). Por ejemplo, vamos a pintar los barrios con color proporcional a la población en cada uno.
#'
#' Primero nos bajamos la población de los barrios de Madrid de <br> http://www-2.munimadrid.es/TSE6/control/seleccionDatosBarrio
#'
pob_barrios <- read.csv("./data/Madrid-Poblacion_Barrios.csv",
colClasses=c("character","character","integer","character","character"))
#'
#' Añadimos a la tabla del mapa una columna que sea la población (uniendo por el GEOCODIGO)
#'
mapb <- merge(mapb,pob_barrios,by="GEOCODIGO")
head(mapb)
#'
#'
#' ## Choropleths
#'
#' Podemos mostrar el choropleth utilizando ggplot y ggmap
#'
ggmap(mm) + geom_sf(data=mapb,inherit.aes = F,aes(fill=Población))
#'
#'
#' ## Choropleths
#'
#' Como siempre, mucho mejor con el paquete `leaflet`. El paquete `leaflet' también tiene opciones para hacer las paletas de colores de manera automática (https://rstudio.github.io/leaflet/colors.html)
#'
#'
pal <- colorNumeric(palett="magma",domain=mapb$Población)
View(mapb)
#'
#'
#'
#'
#' ## Choropleths
#'
#' Una de las visualizacións de información geográfica más utilizada es dibujar los polígonos con colores proporcionales a una variable (choropleths). Por ejemplo, vamos a pintar los barrios con color proporcional a la población en cada uno.
#'
#' Primero nos bajamos la población de los barrios de Madrid de <br> http://www-2.munimadrid.es/TSE6/control/seleccionDatosBarrio
#'
pob_barrios <- read.csv("./data/Madrid-Poblacion_Barrios.csv",
colClasses=c("character","character","integer","character","character"), encoding = 'UTF-8')
pob_barrios
#'
#'
#' ## Choropleths
#'
#' Podemos mostrar el choropleth utilizando ggplot y ggmap
#'
ggmap(mm) + geom_sf(data=mapb,inherit.aes = F,aes(fill=Población))
#'
#' Añadimos a la tabla del mapa una columna que sea la población (uniendo por el GEOCODIGO)
#'
mapb <- merge(mapb,pob_barrios,by="GEOCODIGO")
head(mapb)
#'
#'
#' ## Choropleths
#'
#' Podemos mostrar el choropleth utilizando ggplot y ggmap
#'
ggmap(mm) + geom_sf(data=mapb,inherit.aes = F,aes(fill=Población))
#'
#'
#' ## Choropleths
#'
#' Como siempre, mucho mejor con el paquete `leaflet`. El paquete `leaflet' también tiene opciones para hacer las paletas de colores de manera automática (https://rstudio.github.io/leaflet/colors.html)
#'
#'
pal <- colorNumeric(palett="magma",domain=mapb$Población)
m <- leaflet(data = mapb) %>%
addPolygons(fillColor= ~ pal(Población),weight=1,fillOpacity = 0.8,label=~as.character(DESBDT))
m
#'
#'
#' ## Geolocalizar puntos
#'
#' Una de las operaciones más usuales en datos espaciales es encontrar el polígono (polígonos) donde se encuentra un punto.  Para eso utilizamos la función `st_within` en el paquete `sf`
#'
#' Por ejemplo: ¿en qué barrio está el Bernabeu y el Calderón?
#'
gps_Bernabeu <- c(-3.687909,40.4544)
gps_Calderon <- c(-3.720589,40.40671)
#'
#'
#' Transformamos estos puntos a objetos de `sf`
#'
pto_matrix <- rbind(gps_Bernabeu,gps_Calderon)
estadios <- st_as_sf(data.frame(pto_matrix),coords=c("X1","X2"),crs=4326)
#'
#'
#' Finalmente encontramos el índice (número de polígono) en el que están los puntos y el barrio
#'
id_polygon <- st_within(estadios,mapb)
mapb[as.numeric(id_polygon),]
#'
#'
#' ## Calcular distancias y áreas.
#'
#' Otra de las operaciones más habituales en datos geo-espaciales es medir distancias de un punto a otro o el área de un polígono.
#'
#' Para medir la distancia entre dos puntos, utilizaremos la función `spDists` o `spDistsN2` del paquete `sp`. Por ejemplo, esta es la matriz de distancias entre el Bernabeu y el Calderon
#'
st_distance(estadios) #calcula todas las distancias entre todas las filas de pto_matrix
#'
#'
#' o entre todas las filas y una de ellas en particular
#'
st_distance(estadios,estadios[1,])
estadios
#'
#'
#' Finalmente encontramos el índice (número de polígono) en el que están los puntos y el barrio
#'
id_polygon <- st_within(estadios,mapb)
mapb[as.numeric(id_polygon),]
#'
#'
#'
#' ## Calcular distancias y áreas.
#'
#' Lo mismo para las áreas. Podemos utilizar la función `area` del paquete raster que da el área en metros cuadrados. Por ejemplo, esto es lo que ocupa en km2 el barrio de Los Jerónimos
#'
#'
st_area(mapb[grep("Jerónimos",mapb$DESBDT),],) /1000000
#'
#'
#' mientras que él área del barrio del Pardo es
#'
#'
#'
st_area(mapb[grep("Pardo",mapb$DESBDT),]) /1000000
#' Donde tenemos dos tipos de archivos:
#'
#' - Indicadores para secciones censales (en formato CSV mejor). Mirad también el archivo de "Relación de Indicadores" para saber cuáles son.
#' - Contorno de las secciones censales en formato shapefile.
#'
#'
#' ## Ejercicio 1
#'
#' Cargamos los datos de las secciones censales de la comunidad 13 (Madrid)
#'
indicadores <- read.table("./data/indicadores_seccion_censal_csv/C2011_ccaa13_Indicadores.csv",sep=",",header=T)
#'
#'
#'
#' Y los shapefiles de las secciones censales
#'
map_censales <- read_sf("./data/cartografia_censo2011_nacional/SECC_CPV_E_20111101_01_R_INE.shp",stringsAsFactors=F)
#'
#'
#'
#' ## Calcular distancias y áreas.
#'
#' Lo mismo para las áreas. Podemos utilizar la función `area` del paquete raster que da el área en metros cuadrados. Por ejemplo, esto es lo que ocupa en km2 el barrio de Los Jerónimos
#'
#'
st_area(mapb[grep("Jerónimos",mapb$DESBDT),],) /1000000
#'
#'
#' mientras que él área del barrio del Pardo es
#'
#'
#'
st_area(mapb[grep("Pardo",mapb$DESBDT),]) /1000000
#' Donde tenemos dos tipos de archivos:
#'
#' - Indicadores para secciones censales (en formato CSV mejor). Mirad también el archivo de "Relación de Indicadores" para saber cuáles son.
#' - Contorno de las secciones censales en formato shapefile.
#'
#'
#' ## Ejercicio 1
#'
#' Cargamos los datos de las secciones censales de la comunidad 13 (Madrid)
#'
indicadores <- read.table("./data/indicadores_seccion_censal_csv/C2011_ccaa13_Indicadores.csv",sep=",",header=T)
#'
#'
#'
#' Y los shapefiles de las secciones censales
#'
map_censales <- read_sf("./data/cartografia_censo2011_nacional/SECC_CPV_E_20111101_01_R_INE.shp",stringsAsFactors=F)
#'
#' ## Ejercicio 1
#'
#' Como antes las secciones censales están en otra proyección
#'
#'
st_crs(map_censales)
#'
#'
#' Asi que la cambiamos a WGS84
#'
mapc <- st_transform(map_censales,4326)
#'
#'
#'
#' y os quedamos solo con las de la Comunidad de Madrid
#'
#'
mapc <- mapc[mapc$CCA == 13,]
#'
#'
#'
#' ## Ejercicio 1
#'
#' Para unir los datos de los indicadores y de los shapefiles vamos a utilizar el indicador único `CUSEC`. Pero el archivo de los indicadores no lo tiene. Se lo ponemos
#'
#'
require(stringr)
poblacion <- data.frame(CUSEC = paste(
str_pad(indicadores$cpro, 2, pad = "0"),
str_pad(indicadores$cmun, 3, pad = "0"),
str_pad(indicadores$dist, 2, pad = "0"),
str_pad(indicadores$secc, 3, pad = "0"), sep=""),
poblacion = indicadores$t1_1)
#'
#' Y los juntamos
#'
mapc <- merge(mapc,poblacion,by="CUSEC")
#'
#'
#' ## Ejercicio 1
#'
#' Hacemos un choropleth con la población por seccion censal
#'
#'
pal <- colorNumeric("magma",domain=log(mapc$poblacion))
leaflet(mapc) %>% addTiles() %>%
addPolygons(fillColor = ~pal(log(poblacion)),
fillOpacity = 0.8,weight=0.1)
