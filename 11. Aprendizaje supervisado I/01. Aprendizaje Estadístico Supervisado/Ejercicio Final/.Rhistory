require("knitr")
library("caret")
library("dplyr")
opts_knit$set(root.dir = "C:/Proyectos/AFI/cursos_20212022/Regular")
# setwd("C:/Proyectos/AFI/cursos_20212022/Regular")
setwd("C:/Users/jherraez/Documents/masterAFI/09. Aprendizaje no supervisado/01. Clustering jerarquico y no jerarquico/")
####################
# Lectura de datos #
####################
datosBanca <- read.csv("Data/datosBanca.csv", header = TRUE, sep=",")
set.seed(1404)
datosBanca <- datosBanca[sample(nrow(datosBanca), nrow(datosBanca) * 0.8), ]
rownames(datosBanca) <- 1:nrow(datosBanca)
summary(datosBanca)
# Estandarización mediante discretización
# install.packages("nima")
library(nima)
datosBanca$checkingAccount_CAT <- discrete_by_quantile(datosBanca$checkingAccount)/4
datosBanca$deposit_CAT <- discrete_by_quantile(datosBanca$deposit)/4
datosBanca$shareOfStock_CAT <- discrete_by_quantile(datosBanca$shareOfStock)/4
datosBanca$pensionPlan_CAT <- discrete_by_quantile(datosBanca$pensionPlan)/4
#datosBanca$mortgage_CAT<-discrete_by_quantile(datosBanca$mortgage)/4
# Como da un error, la asignamos con IF
summary(datosBanca$mortgage)
datosBanca$mortgage_CAT <- datosBanca$mortgage
datosBanca$mortgage_CAT <- ifelse(datosBanca$mortgage <= 0, 1, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(0<datosBanca$mortgage & datosBanca$mortgage<= 45104, 2, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(45104<datosBanca$mortgage & datosBanca$mortgage<= 125979, 3, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(125979<datosBanca$mortgage, 4, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- datosBanca$mortgage_CAT/4
summary(datosBanca$mortgage_CAT)
datosBanca$loan_CAT<-discrete_by_quantile(datosBanca$loan)/4
datosBanca$cards_CAT<-discrete_by_quantile(datosBanca$cards)/4
datosBanca$insurance_CAT<-discrete_by_quantile(datosBanca$insurance)/4
datosBanca$billPayment_CAT<-discrete_by_quantile(datosBanca$billPayment)/4
# La domiciliación de nómina es binaria y no es preciso estandarizarla
# Importante hacerla numérica porque si no, la considera integer y su AVERAGE vía SQL devuelve 0
datosBanca$salary_CAT<-as.numeric(datosBanca$salary)
summary(datosBanca)
# Cambiar missings por 0 #
datosBanca$checkingAccount_CAT[is.na(datosBanca$checkingAccount_CAT)]<-0
datosBanca$deposit_CAT[is.na(datosBanca$deposit_CAT)]<-0
datosBanca$shareOfStock_CAT[is.na(datosBanca$shareOfStock_CAT)]<-0
datosBanca$pensionPlan_CAT[is.na(datosBanca$pensionPlan_CAT)]<-0
datosBanca$mortgage_CAT[is.na(datosBanca$mortgage_CAT)]<-0
datosBanca$loan_CAT[is.na(datosBanca$loan_CAT)]<-0
datosBanca$cards_CAT[is.na(datosBanca$cards_CAT)]<-0
datosBanca$insurance_CAT[is.na(datosBanca$insurance_CAT)]<-0
datosBanca$billPayment_CAT[is.na(datosBanca$billPayment_CAT)]<-0
datosBanca.cat <- datosBanca %>%
select(ends_with('_CAT'))
library(cluster)
library(factoextra)
library(vegan)
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
matrizDistancias <- vegdist(datosBanca.cat, method = "euclidean")
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
matrizDistancias <- vegdist(datosBanca.cat.subset, method = "euclidean")
clusterJerarquico <- hclust(matrizDistancias, method="ward.D2")
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
library(dendextend)
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
rect.hclust(clusterJerarquico, k=2, border="red")
rect.hclust(clusterJerarquico, k=3, border="blue")
rect.hclust(clusterJerarquico, k=4, border="green")
rect.hclust(clusterJerarquico, k=5, border="yellow")
rect.hclust(clusterJerarquico, k=6, border="purple")
rect.hclust(clusterJerarquico, k=7, border="gray")
rect.hclust(clusterJerarquico, k=8, border="black")
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
rownames(datosBanca.cat.subset) <- 1:nrow(datosBanca.cat.subset)
matrizDistancias <- vegdist(datosBanca.cat.subset, method = "euclidean")
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
rect.hclust(clusterJerarquico, k=2, border="red")
rect.hclust(clusterJerarquico, k=3, border="blue")
rect.hclust(clusterJerarquico, k=4, border="green")
rect.hclust(clusterJerarquico, k=5, border="yellow")
rect.hclust(clusterJerarquico, k=6, border="purple")
rect.hclust(clusterJerarquico, k=7, border="gray")
rect.hclust(clusterJerarquico, k=8, border="black")
dend <- as.dendrogram(clusterJerarquico)
dend <- color_branches(dend, k=4)
plot(dend)
library(dplyr)
library(caret)
rm(list = ls())
setwd("C:/Users/jherraez/Documents/masterAFI/11. Aprendizaje supervisado I/01. Aprendizaje Estadístico Supervisado/Ejercicio Final")
# setwd("C:/Users/Javier/Documents/masterAFI/11. Aprendizaje supervisado I/01. Aprendizaje Estadístico Supervisado/Ejercicio Final")
cancer_df <- read.csv("BreastCancerData.csv", na.strings = 100, stringsAsFactors = T)
target <- colnames(cancer_df)[ncol(cancer_df)]
target
table(cancer_df[, target])
colnames(cancer_df)[ncol(cancer_df)] <- "Relapse"
levels(cancer_df$Relapse) <- c("No", "Yes")
hist(rowSums(is.na(cancer_df)))
table(rowSums(is.na(cancer_df)))
hist(colSums(is.na(cancer_df)))
table(colSums(is.na(cancer_df)))
#borrar columnas con todos missing values
nasColumns <- sapply(cancer_df, function(x) all(is.na(x)))
cancer_df <- cancer_df[, !(nasColumns)]
table(rowSums(is.na(cancer_df)))
table(colSums(is.na(cancer_df)))
cancer_df <- cancer_df[!(rowSums(is.na(cancer_df)) > 10000),]
row.names(cancer_df) <- 1:nrow(cancer_df)
table(colSums(is.na(cancer_df)))
nasColumns_2 <- sapply(cancer_df, function(x) any(is.na(x)))
cancer_df <- cancer_df[, !(nasColumns_2)]
table(colSums(is.na(cancer_df)))
genes <- cancer_df[,1:ncol(cancer_df) - 1]
ctrl <- trainControl(method = "cv",
number = 5,
classProbs = TRUE
)
library(cluster)
library(vegan)
library(dplyr)
library(factoextra)
genes_traspose <- as.data.frame(t(genes))
set.seed(1404)
# genes_traspose.subset <- genes_traspose[sample(nrow(genes_traspose), nrow(genes_traspose) * 0.1), ]
samples <- createDataPartition(genes_traspose$`1`, p = 0.1, list = FALSE)
genes_traspose.subset  <- genes_traspose[samples, ]
# Possible values are "silhouette" (for average silhouette width), "wss" (for total within sum of square) and "gap_stat" (for gap statistics).
pm <- eclust(genes_traspose.subset, FUNcluster="pam", k = 20, hc_metric = "euclidean", hc_method = "ward.D2")
?eclust
# Possible values are "silhouette" (for average silhouette width), "wss" (for total within sum of square) and "gap_stat" (for gap statistics).
pm <- eclust(genes_traspose.subset, FUNcluster="pam", k = 20, hc_metric = "euclidean", hc_method = "ward.D2", graph = F)
medoids <- rownames(pm$medoids)
cancer_clustering <- cancer_df[, c(medoids, "Relapse")]
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl)
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
fviz_nbclust(genes_traspose.subset, pam, method="wss", k.max = 50) + theme_classic()
fviz_nbclust(genes_traspose.subset, pam, method="gap_stat", k.max = 50) + theme_classic()
fviz_nbclust(genes_traspose.subset, pam, method="wss", k.max = 50) + theme_classic()
fviz_nbclust(genes_traspose.subset, pam, method="silhouette", k.max = 50) + theme_classic()
set.seed(1404)
# genes_traspose.subset <- genes_traspose[sample(nrow(genes_traspose), nrow(genes_traspose) * 0.1), ]
samples <- createDataPartition(genes_traspose$`1`, p = 0.1, list = FALSE)
genes_traspose.subset  <- genes_traspose[samples, ]
fviz_nbclust(genes_traspose.subset, pam, method="wss", k.max = 50) + theme_classic()
fviz_nbclust(genes_traspose.subset, pam, method="silhouette", k.max = 50) + theme_classic()
# Possible values are "silhouette" (for average silhouette width), "wss" (for total within sum of square) and "gap_stat" (for gap statistics).
pm <- eclust(genes_traspose.subset, FUNcluster="pam", k = 20, hc_metric = "euclidean", hc_method = "ward.D2", graph = F)
medoids <- rownames(pm$medoids)
cancer_clustering <- cancer_df[, c(medoids, "Relapse")]
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl,
preProcess = c("center", "scale"))
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
# Possible values are "silhouette" (for average silhouette width), "wss" (for total within sum of square) and "gap_stat" (for gap statistics).
pm <- eclust(genes_traspose.subset, FUNcluster="pam", k = 30, hc_metric = "euclidean", hc_method = "ward.D2", graph = F)
medoids <- rownames(pm$medoids)
cancer_clustering <- cancer_df[, c(medoids, "Relapse")]
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl,
preProcess = c("center", "scale"))
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
set.seed(1404)
samples <- createDataPartition(genes_traspose$`1`, p = 0.2, list = FALSE)
genes_traspose.subset  <- genes_traspose[samples, ]
fviz_nbclust(genes_traspose.subset, pam, method="wss", k.max = 50) + theme_classic()
library(dplyr)
library(caret)
rm(list = ls())
setwd("C:/Users/jherraez/Documents/masterAFI/11. Aprendizaje supervisado I/01. Aprendizaje Estadístico Supervisado/Ejercicio Final")
# setwd("C:/Users/Javier/Documents/masterAFI/11. Aprendizaje supervisado I/01. Aprendizaje Estadístico Supervisado/Ejercicio Final")
cancer_df <- read.csv("BreastCancerData.csv", na.strings = 100, stringsAsFactors = T)
target <- colnames(cancer_df)[ncol(cancer_df)]
target
table(cancer_df[, target])
colnames(cancer_df)[ncol(cancer_df)] <- "Relapse"
levels(cancer_df$Relapse) <- c("No", "Yes")
hist(rowSums(is.na(cancer_df)))
table(rowSums(is.na(cancer_df)))
hist(colSums(is.na(cancer_df)))
table(colSums(is.na(cancer_df)))
#borrar columnas con todos missing values
nasColumns <- sapply(cancer_df, function(x) all(is.na(x)))
cancer_df <- cancer_df[, !(nasColumns)]
table(rowSums(is.na(cancer_df)))
table(colSums(is.na(cancer_df)))
cancer_df <- cancer_df[!(rowSums(is.na(cancer_df)) > 10000),]
row.names(cancer_df) <- 1:nrow(cancer_df)
table(colSums(is.na(cancer_df)))
nasColumns_2 <- sapply(cancer_df, function(x) any(is.na(x)))
cancer_df <- cancer_df[, !(nasColumns_2)]
table(colSums(is.na(cancer_df)))
####################################################
ctrl <- trainControl(method = "cv",
number = 5,
classProbs = TRUE
)
genes <- cancer_df[,1:ncol(cancer_df) - 1]
pre <- preProcess(genes, method = c("pca"), thresh = 0.9)
rdaFit <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = predict(pre, cancer_df),
trControl = ctrl)
rdaPred = predict(rdaFit, predict(pre, cancer_df))
confusionMatrix(rdaPred, cancer_df$Relapse)
########################################################
library(cluster)
library(vegan)
library(dplyr)
library(factoextra)
genes_traspose <- as.data.frame(t(genes))
set.seed(1404)
samples <- createDataPartition(genes_traspose$`1`, p = 0.1, list = FALSE)
genes_traspose.subset  <- genes_traspose[samples, ]
fviz_nbclust(genes_traspose.subset, pam, method="wss", k.max = 50) + theme_classic()
# "wss" (for total within sum of square)
pm <- eclust(genes_traspose.subset, FUNcluster="pam", k = 30, hc_metric = "euclidean", hc_method = "ward.D2", graph = F)
medoids <- rownames(pm$medoids)
cancer_clustering <- cancer_df[, c(medoids, "Relapse")]
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl,
preProcess = c("center", "scale"))
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl,
# preProcess = c("center", "scale")
)
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
rdaFitClust <- train(Relapse ~ .,
method = "rda",
tuneGrid = expand.grid(gamma = seq(0.1, 1, .1), lambda = seq(0.1, 1, .1)),
metric = "Kappa",
data = cancer_clustering,
trControl = ctrl,
preProcess = c("center")
)
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
rdaPredClust = predict(rdaFitClust, test, type="prob")
rdaPredClust = predict(rdaFitClust, genes, type="prob")
rdaProbClust
rdaProbClust = predict(rdaFitClust, genes, type="prob")
rdaProbClust
rdaPredClust = rep("No", nrow(genes))
rdaPredClust
rdaPredClust[which(rdaProbClust[,2] > threshold)] = "Yes"
threshold <- 0.2
rdaPredClust[which(rdaProbClust[,2] > threshold)] = "Yes"
rdaPredClust
cost.unit <- c(0, 1, 5, 0)
CM = confusionMatrix(factor(rdaPred), testing$Churn)$table
CM = confusionMatrix(rdaPredClust, cancer_df$Relapse)$table
CM = confusionMatrix(factor(rdaPredClust), cancer_df$Relapse)$table
cost = sum(as.vector(CM)*cost.unit)/sum(CM)
cost
threshold <- 0.2
rdaProbClust = predict(rdaFitClust, genes, type="prob")
rdaPredClust = rep("No", nrow(genes))
rdaPredClust[which(rdaProbClust[,2] > threshold)] = "Yes"
CM = confusionMatrix(factor(rdaPredClust), cancer_df$Relapse)$table
cost = sum(as.vector(CM)*cost.unit)/sum(CM)
cost
rdaPredClust = predict(rdaFitClust, genes)
confusionMatrix(rdaPredClust, cancer_df$Relapse)
cost.unit <- c(0, 1, 5, 0)
CM = confusionMatrix(factor(rdaPredClust), cancer_df$Relapse)$table
cost = sum(as.vector(CM)*cost.unit)/sum(CM)
cost
threshold <- 0.2
rdaProbClust = predict(rdaFitClust, genes, type="prob")
rdaPredClust = rep("No", nrow(genes))
rdaPredClust[which(rdaProbClust[,2] > threshold)] = "Yes"
CM = confusionMatrix(factor(rdaPredClust), cancer_df$Relapse)$table
cost = sum(as.vector(CM)*cost.unit)/sum(CM)
cost
