gg.disc
# Escala de color en blanco y negro
gg.disc +
scale_fill_grey()
# Escala de color basada en paleta de colores
gg.disc +
scale_fill_brewer(palette = "Blues")
# Listado de paletas disponibles en ggplot2: http://colorbrewer2.org/
library(RColorBrewer)
display.brewer.all()
# Modificación de escala de tamaño sobre variable continua
gg.cont <- ggplot(diamonds, aes(x = carat, y = price, size = price)) +
geom_point()
gg.cont
# Escala de tamaño continua sobre el radio
gg.cont +
scale_size_continuous(range = c(0.05, 5))
# Escala de tamaño continua sobre el área
gg.cont +
scale_size_area(max_size = 10)
# Modificación de escala de forma sobre variable continua
gg.cont <- ggplot(diamonds, aes(x = carat, y = price, shape = price)) +
geom_point()
gg.cont
# Modificación de escala de forma sobre variable discreta
gg.disc <- ggplot(diamonds, aes(x = carat, y = price, shape = cut)) +
geom_point()
gg.disc
# Escala de forma manual
gg.disc +
scale_shape_manual(values = c(3:7))
# Incluimos los paquetes necesarios
library(ggplot2)
library(tidyr)
ggplot(present, aes(x = year.day, y = temp)) +
geom_line()
ggplot(present, aes(x = year.day, y = temp)) +
geom_line(aes(col = temp)) +
scale_color_gradient2(low = "blue", high = "red", mid = "white", midpoint = 15)
ggplot(present, aes(x = year.day, y = temp)) +
geom_line(alpha = 0.5, linetype="dotted") +
geom_point(aes(col = temp), size = 1) +
scale_color_gradient2(low = "blue", high = "red", mid = "white", midpoint = 15) +
geom_point(col = "black", shape = 1, alpha = 0.5)
ggplot(present, aes(x = year.day, y = temp)) +
geom_line(alpha = 0.5, linetype="dotted") +
geom_point(aes(col = temp, size=temp)) +
scale_color_gradient2(low = "blue", high = "red", mid = "white", midpoint = 15) +
geom_point(aes(size=temp), col = "black", shape = 1, alpha = 0.5) +
scale_y_continuous(limits = c(0, 15)) +
scale_size_continuous(range = c(1, 5))
# Incluimos el paquete
library(ggplot2)
# Estudiemos el set de datos
str(iris)
head(iris)
# Una variable continua
# ---------------------
gg <- ggplot(iris, aes(x = Petal.Length))
# Área
gg +
geom_area(stat = "bin", bins = 10)
# Histograma
gg +
geom_histogram(binwidth=1)
# Densidad
gg +
geom_density()
# Histograma de puntos
gg +
geom_dotplot()
# Dos variables continuas
# -----------------------
gg <- ggplot(iris, aes(x = Sepal.Width, y = Sepal.Length))
# Scatter plot
gg +
geom_point()
# Scatter con ruido
gg +
geom_jitter()
# Linea
gg +
geom_line()
# Distribución de observaciones por eje (rug)
gg +
geom_rug()
# Smooth / regresión
gg +
geom_smooth(method = "loess")
# Texto
gg +
geom_text(aes(label = substr(Species, 1, 2)))
# Densidad / curvas de nivel
gg +
geom_density2d()
# Tiles 2D
gg +
geom_bin2d()
# Una variable discreta y una continua
# ------------------------------------
gg <- ggplot(iris, aes(x = Species, y = Sepal.Length))
# Barras
gg +
geom_bar(stat="identity")
# Scatter
gg +
geom_point()
# Scatter con ruido (barras con distribución)
gg +
geom_jitter(width=0.5)
# Boxplot
gg +
geom_boxplot()
# Violin
gg +
geom_violin()
# Una variable discreta y un rango
# --------------------------------
df <- data.frame(type = c("A", "B"), value = 4:5, variation = 1:2)
gg <- ggplot(df, aes(type, value, ymin = value - variation, ymax = value + variation))
# Boxplot sin bigotes
gg +
geom_crossbar()
# Barra de "error"
gg +
geom_errorbar()
# Rango por linea
gg +
geom_linerange()
# Incluimos el paquete
library(ggplot2)
# Analizamos el set de datos
str(mtcars)
head(mtcars)
# Generamos un gráfico de barras
gg <- ggplot(mtcars, aes(x = as.factor(cyl), fill = as.factor(am)))
gg +
geom_bar()
# Posicionamiento "uno al lado del otro"
gg +
geom_bar(position = "dodge")
# Modificamos el posicionamiento en X para que haya solapamiento
gg +
geom_bar(size = 1, position = position_dodge(width = 0.5))
# Posicionamiento "uno encima del otro"
gg +
geom_bar(position = "stack")
# Generamos un gráfico de barras
gg <- ggplot(mtcars, aes(x = as.factor(cyl), fill = as.factor(am)))
gg +
geom_bar()
# Posicionamiento "uno al lado del otro"
gg +
geom_bar(position = "dodge")
# Modificamos el posicionamiento en X para que haya solapamiento
gg +
geom_bar(size = 1, position = position_dodge(width = 0.5))
# Posicionamiento "uno encima del otro"
gg +
geom_bar(position = "stack")
# Posicionamiento "uno encima del otro normalizado"
gg +
geom_bar(position = "fill")
# Un ejemplo de overplotting
gg <- ggplot(mtcars, aes(x = as.factor(cyl), y = as.factor(am), col = as.factor(gear)))
gg +
geom_point(size = 3)
# Con geom_jitter lo solucionamos
gg +
geom_jitter(size = 3)
# geom_jitter es un alias para
gg +
geom_point(size = 3, position = "jitter")
# Establecemos los parámetros de la función de posición
gg +
geom_point(size = 2, position = position_jitter(width = 0.5, height = 0.5))
# Establecemos los parámetros de la función de posición
gg +
geom_point(size = 2, position = position_jitter(width = 0.1, height = 0.1))
# Incluimos los paquetes necesarios
library(ggplot2)
# Pintamos la serie de las temperatura máximas y mínimas históricas
# como un gráfico de rango por línea con color "wheat"
ggplot(past, aes(x = year.day, ymin = min, ymax = max)) +
geom_linerange(col = "wheat")
# Pintamos la serie de las temperaturas históricas al 95% como un gráfico
# de rango por línea con color "wheat4"
ggplot(past, aes(x = year.day, ymin = mean_inf, ymax = mean_sup)) +
geom_linerange(col = "wheat4")
# Pintamos la serie de las temperaturas del presente año como un gráfico de línea
# de grosor 0.3
ggplot(present, aes(x = year.day, y = temp)) +
geom_line(size = 0.3)
# Pintamos la serie de las temperaturas superiores a la histórica como un gráfico de puntos
# de tamaño 1 y color firebrick3
ggplot(present.highs, aes(x = year.day, y = temp)) +
geom_point(col = "firebrick3", size = 1)
# Pintamos la serie de las temperaturas inferiores a la histórica como un gráfico de puntos
# de tamaño 1 y color blue3
ggplot(present.lows, aes(x = year.day, y = temp)) +
geom_point(col = "blue3", size=1)
# Unimos todas las series en un único gráfico
ggplot() +
geom_linerange(data = past, aes(x = year.day, ymin = min, ymax = max), col = "wheat") +
geom_linerange(data = past, aes(x = year.day, ymin = mean_inf, ymax = mean_sup), col = "wheat4") +
geom_line(data = present, aes(x = year.day, y = temp), size = 0.3) +
geom_point(data = present.highs, aes(x = year.day, y = temp), col = "firebrick3", size = 1) +
geom_point(data = present.lows, aes(x = year.day, y = temp), col = "blue3", size=1)
# Modifica la escala de los ejes X e Y para que:
# Eje X: contenga los nombres de los meses en castellano (en el punto medio de cada mes)
# EJE Y: contenga las temperaturas en formato XXº desde -5 hasta 55 cada 5 grados
# Elimina también los nombres de los ejes (o déjalos en blanco)
# Elimina el margen del gráfico
y.values <- seq(-5, 55, 5)
y.labels <- sapply(y.values, function(x) { paste0(as.character(x), 'º') })
x.values <- seq(15, 365, 30)
x.labels <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
ggplot() +
geom_linerange(data = past, aes(x = year.day, ymin = min, ymax = max), col = "wheat") +
geom_linerange(data = past, aes(x = year.day, ymin = mean_inf, ymax = mean_sup), col = "wheat4") +
geom_line(data = present, aes(x = year.day, y = temp), size = 0.3) +
geom_point(data = present.highs, aes(x = year.day, y = temp), col = "firebrick3", size = 1) +
geom_point(data = present.lows, aes(x = year.day, y = temp), col = "blue3", size=1) +
scale_y_continuous(breaks = y.values, labels = y.labels, name = "", expand = c(0, 0)) +
scale_x_continuous(breaks = x.values, labels = x.labels, name = "", expand = c(0, 0))
# Incluimos el paquete
library(ggplot2)
# Volvamos al ejemplo básico
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_point()
# Añadimos un suavizado mediante el uso del stat_smooth
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_point() +
stat_smooth()
# Algunos parámetros
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_point() +
stat_smooth(method="loess", n = 10, level = 0.99, se = T)
# Pintamos únicamente el stat
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
stat_smooth()
# Modificamos el geom del stat
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
stat_smooth(geom = "line")
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
stat_smooth(geom = "point")
# Modificamos los aesthetics del stat
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
stat_smooth(aes(fill = Species), alpha = 0.2)
# Volvmeos al gráfico de siempre
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
geom_point()
# Añadamos una estaística de cuantiles
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
stat_quantile()
# Algunos parámetros
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
geom_point() +
stat_quantile(quantiles = c(0, 0.25, 0.50, 0.75, 1))
# Podemos usar las variables generadas por el stat
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
stat_quantile(quantiles = c(0, 0.25, 0.50, 0.75, 1), aes(col = as.factor(..quantile..)))
# Conteos
ggplot(iris, aes(x = Species)) +
stat_count()
# Discretización
ggplot(iris, aes(x = Sepal.Length)) +
stat_bin(bins = 30)
# Densidad 1D
ggplot(iris, aes(x = Sepal.Length)) +
stat_density()
# Densidad 2D
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
stat_density2d(aes(col = ..level..))
# Boxplot
ggplot(iris, aes(x = Species, y = Sepal.Width)) +
stat_boxplot()
# Incluimos el paquete
library(ggplot2)
# Mostremos en un grafico quilates contra precio con identificación de claridad
gg <- ggplot(diamonds, aes(x = carat, y = price, col = clarity)) +
geom_point()
gg
# De una forma mucho más clara
gg +
facet_wrap(~clarity)
# Veamos un gráfico de distribución de precios por corte
gg <- ggplot(diamonds, aes(x = price, fill = cut))
gg +
geom_bar()
# Mejoremos la visualización normalizando
gg +
geom_bar(position="fill")
# Mejoremos la visualización colocando las métricas de forma adyacente
gg +
geom_bar(position="dodge")
# Mejoremos la visualización desagregando por corte
gg +
geom_bar() +
facet_wrap(~cut)
# Mejoremos la visualización ordenando la desagregación
gg +
geom_bar() +
facet_wrap(~cut, ncol = 1)
# Mejoremos la visualización viendo densidad en lugar de conteo
gg +
geom_density(aes(col = cut)) +
facet_wrap(~cut, ncol = 1)
# Estudiemos la relación entre caballos y consumo en coches de diferente cilindrada y cambio
gg <- ggplot(mtcars, aes(x = mpg, y = hp, col = as.factor(am), shape = as.factor(cyl)))
gg +
geom_point()
# Mejoremos la visualización mediante tamaños y transparencias
gg +
geom_point(size = 2, alpha = 0.5)
# Mejoremos la visualización para que el eje de consumo sea más fácilmente interpretable
gg <- ggplot(mtcars, aes(x = 1 / mpg, y = hp, col = as.factor(am), shape = as.factor(cyl)))
gg +
geom_point(size = 2, alpha = 0.5) +
scale_x_continuous(name = "gpm")
# Mejoremos la visualización representando cada variable según cada criterio
gg <- ggplot(mtcars, aes(x = 1 / mpg, y = hp))
gg +
geom_point(size = 2, col = "skyblue4") +
facet_grid(am ~ cyl) +
scale_x_continuous(name = "gpm")
# Mejoremos la visualización indicando el nombre de la variable que desagrega
gg +
geom_point(size = 2, col = "skyblue4") +
facet_grid(am ~ cyl, labeller = label_both) +
scale_x_continuous(name = "gpm")
# Incluimos el paquete
library(ggplot2)
# Gráfico de barras que muestra la distribución por claridades
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar()
# Gráfico de tarta que muestra la distribución por claridades
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar() +
coord_polar()
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar() +
coord_polar(theta="y")
ggplot(diamonds, aes(x = 0, fill = clarity)) +
geom_bar() +
coord_polar(theta="y")
# Gráfico de quilates contra precio
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point()
# Gráfico de barras que muestra la distribución por claridades
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar()
# Gráfico de tarta que muestra la distribución por claridades
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar() +
coord_polar()
ggplot(diamonds, aes(x = clarity, fill = clarity)) +
geom_bar() +
coord_polar(theta="y")
ggplot(diamonds, aes(x = 0, fill = clarity)) +
geom_bar() +
coord_polar(theta="y")
# Gráfico de quilates contra precio
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point()
# Zoom para observar el corte de precios
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point() +
scale_x_continuous(limits = c(0, 1.5)) +
scale_y_continuous(limits = c(0, 2000))
# Zoom "correcto" para observar el corte de precios
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point() +
coord_cartesian(xlim = c(0, 1.5), ylim = c(0, 2000))
# Gráfico de corte contra claridad
ggplot(diamonds, aes(x = cut, y = clarity)) +
geom_jitter()
# Mantenemos relación de aspecto para no "penalizar" variables con más categorías
ggplot(diamonds, aes(x = cut, y = clarity)) +
geom_jitter() +
coord_fixed(ratio=1)
# Ejes alineados con aesthetics
ggplot(diamonds, aes(x = cut)) +
stat_count()
# Ejes invertidos
ggplot(diamonds, aes(x = cut)) +
stat_count() +
coord_flip()
# Incluimos el paquete
library(ggplot2)
# Gráfico con estilo básico
gg <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_jitter()
gg
# PROPIEDADES DE LINEA
# --------------------
gg <- gg +
theme(axis.line = element_line(color = "black", size=1),
axis.ticks = element_line(color = "black", size=1),
panel.grid.major = element_line(color = "lightgrey", linetype=2),
panel.grid.minor = element_line(color = "lightgrey", linetype=2))
gg
# PROPIEDADES DE CONTENEDOR
# -------------------------
gg <- gg +
theme(panel.background = element_blank(),
legend.background = element_rect(color="black"),
legend.key = element_blank())
gg
# PROPIEDADES DE TEXTO
# --------------------
gg <- gg +
theme(axis.title = element_text(size = 14, color = "#555555", face="bold", hjust = 1),
axis.text = element_text(color = "black", size=12, face = "bold"),
legend.title = element_text(size = 14, color = "#555555", face="bold", hjust = 1),
legend.text = element_text(size = 14, color = "#555555"))
gg
# TEMAS PREDEFINIDOS
# ------------------
gg <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_jitter()
gg + theme_bw()
gg + theme_light()
gg + theme_linedraw()
# Obtención de tema por defecto
default.theme <- theme_get()
default.theme$panel.background
# Actualización de tema por defecto
theme_update(panel.background = element_blank())
gg
# Establecimiento del tema por defecto
new.theme <- default.theme + theme(panel.background = element_rect(fill = "red"))
gg + new.theme
theme_set(new.theme)
gg
theme_set(default.theme)
gg
# Incluimos el paquete
library(ggplot2)
# Gráfico básico
gg <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
geom_jitter()
gg
# Anotaciones de texto
gg + annotate("text", label = "Anotación de texto", x = 4, y = 5, hjust = 0, face = "bold", family = "Courier")
# Anotaciones de segmento
gg + annotate("segment", x = 4.5, y = 2.5, xend = 6.5, yend = 4, col = "red", size = 2)
# Anotaciones de rectángulo
gg + annotate("rect", xmin = 5.8, xmax = 7, ymin = 2.5, ymax = 3.5, fill = "blue", alpha = 0.1)
# Incluimos los paquetes necesarios
library(ggplot2)
# Recuperamos el gráfico en el que teníamos los geoms y los scales correctos
y.values <- seq(-5, 55, 5)
y.labels <- sapply(y.values, function(x) { paste0(as.character(x), 'º') })
x.values <- seq(15, 365, 30)
x.labels <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
chart <- ggplot() +
geom_linerange(data = past, aes(x = year.day, ymin = min, ymax = max), col = "wheat") +
geom_linerange(data = past, aes(x = year.day, ymin = mean_inf, ymax = mean_sup), col = "wheat4") +
geom_line(data = present, aes(x = year.day, y = temp), size = 0.3) +
geom_point(data = present.highs, aes(x = year.day, y = temp), col = "firebrick3", size = 1) +
geom_point(data = present.lows, aes(x = year.day, y = temp), col = "blue3", size=1) +
scale_y_continuous(breaks = y.values, labels = y.labels, name = "", expand = c(0, 0)) +
scale_x_continuous(breaks = x.values, labels = x.labels, name = "", expand = c(0, 0))
# Ajustamos el estilo del panel del gráfico:
# - Fondo blanco / Sin fondo
chart <- chart + theme(panel.background = element_blank())
# Añade una línea vertical (geom_vline) con:
# - Valor (xintercept) en 0
# - Color: wheat4
# - Tamaño: 1
chart <- chart + geom_vline(xintercept = 0, col = "wheat4", size = 1)
# Ajustamos el estilo de los ejes:
# - Sin ticks
# - Tamaño de fuente: 8
# - Color de fuente: #bbbbbb
chart <- chart + theme(axis.ticks = element_blank(), axis.text = element_text(colour = "#bbbbbb", size=8))
# Ajustamos el estilo del grid:
# - Eje X: línea de puntos, tamaño 0.2, color wheat4 sólo en cortes menores
chart <- chart + theme(panel.grid.minor.x = element_line(linetype = 3, size = .2, colour = "wheat4"))
# Establecemos el título del gráfico: Datos de Madrid 2014
chart <- chart + ggtitle(label = "Datos de Madrid 2014")
# Ajustamos el estilo del título:
# - Negrita
# - Tamaño: 20
# - Color: #3c3c3c
chart <- chart + theme(plot.title = element_text(size = 20, face = "bold", colour = "#3c3c3c"))
# Reajustemos los ejes para que el eje y esté mucho más holgado
chart <- chart + coord_cartesian(ylim = c(-5, 40))
# Introduzcamos el subtítulo "Temperatura" como anotación
# - Negrita
# - Tamaño: 4
# - Color: #3c3c3c
# - Ajuste horizontal: 0
# - Ajuste veritcal: 1
chart <- chart + annotate("text", x = 8, y = 40, size = 4, colour = "#3c3c3c", label = "Temperatura", hjust = 0, vjust = 1, fontface = "bold")
# Introduzcamos el texto de explicación como anotación
# - Tamaño: 4
# - Color: #bbbbbb
texto <- "Los datos representan la temperatura media diaria."
chart <- chart + annotate("text", x = 8, y = 38, size = 4, colour = "#bbbbbb", label = texto, hjust = 0, vjust = 1)
# Introduzcamos los textos y segmentos de explicación de un punto de mínimo histórico
chart <- chart + annotate("segment", x = present.lows$year.day[1] + 4,
y = present.lows$temp[1] - 5,
xend = present.lows$year.day[1] + 0.5,
yend = present.lows$temp[1] - 0.5,
colour = "blue3", size = 0.5,
arrow = arrow(length = unit(0.2, "cm")))
chart <- chart + annotate("text", x = present.lows$year.day[1] + 4, y = present.lows$temp[1] - 5.5,
label = "Hay 2 días para los que\ntenemos mínimo histórico", hjust = 0.2, vjust = 1,
size = 2.5, colour = "blue3")
chart
