plot(d,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit1$alpha,
col="#b00606")
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="#000066")
# plot the degree distribution on a log-log plot
plot(degree_distribution,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# plot the degree distribution on a log-log plot
plot(degree_distribution,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# plot the degree distribution on a log-log plot
plot(deg_dist,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit1$alpha,
col="#b00606")
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="#000066")
table(d)
table(deg_dist)
# plot the degree distribution on a log-log plot
plot(deg_dist + 0.0001,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# Distribución de grados y ajuste a una Power-Law
graph.density(gg3)
d <- degree(gg3)
fit <- fit_power_law(d)
deg_dist <- degree_distribution(gg3)
fit1 <- fit_power_law(deg_dist)
# plot the degree distribution on a log-log plot
plot(deg_dist + 0.0001,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit1$alpha,
col="#b00606")
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="#000066")
deg_dist
table(deg_dist)
seq(deg_dist)
deg_dist
seq(deg_dist)^-fit1$alpha
# plot the degree distribution on a log-log plot
plot(d + 0.0001,
#log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(d),
seq(d)^-fit1$alpha,
col="#b00606")
lines(seq(d),
seq(d)^-fit$alpha,
col="#000066")
# plot the degree distribution on a log-log plot
plot(d, #+ 0.0001,
#log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(d),
seq(d)^-fit1$alpha,
col="#b00606")
lines(seq(d),
seq(d)^-fit$alpha,
col="#000066")
# Distribución de grados y ajuste a una Power-Law
graph.density(gg3)
# Distribución de grados y ajuste a una Power-Law
graph.density(gg3)
deg_dist <- degree_distribution(gg3)
fit <- fit_power_law(deg_dist)
# plot the degree distribution on a log-log plot
plot(deg_dist + 0.0001,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="#000066")
# plot the degree distribution on a log-log plot
plot(deg_dist + 0.0001,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="red")
library(igraph)
rm(list = ls())
setwd("C:/Users/Javier/Documents/masterAFI/18. Analisis de Grafos/01. Redes sociales/practica/")
dd <- read.csv("red_contactos.csv", sep = ";")
gg <- graph.data.frame(dd, directed = FALSE)
summary(gg)
vcount(gg)
ecount(gg)
gg2 <- simplify(gg, remove.multiple = TRUE, remove.loops = TRUE)
E(gg2)$weight = sapply(E(gg2), function(e) {
length(all_shortest_paths(gg, from = ends(gg2, e)[1], to = ends(gg2, e)[2])$res) } )
summary(gg)
table(E(gg2)$weight)
is.connected(gg2) # es conexo?
ccs <- components(gg2)
ccs$csize
id_compmayor <- which.max(ccs$csize) # mayor componente conexa
vids <- ccs$membership == id_compmayor
vids <- which(ccs$membership == id_compmayor) #nodos de la comp conexa mayor
gg3 <- induced_subgraph(gg2, vids = vids ) #subbgrafo solamente con estos nodos
summary(gg3)
# grado medio
mean(degree(gg3))
# distancia media
average.path.length(gg3)
# diámetro
diameter(gg3)
# Distribución de grados y ajuste a una Power-Law
graph.density(gg3)
deg_dist <- degree_distribution(gg3)
fit <- fit_power_law(deg_dist)
fit
# plot the degree distribution on a log-log plot
plot(deg_dist + 0.0001,
log = "xy",
xlab = "Node Degree",
ylab = "Probability")
# add the fitted power law line; the exponent value comes from alpha, part of
# the output of the fit.power.law() function.
lines(seq(deg_dist),
seq(deg_dist)^-fit$alpha,
col="red")
# Clustering
mean(degree(gg3))
# grado medio
mean(degree(gg3))
### Inserta aqui tu codigo
### Inserta aqui tu codigo
### Inserta aqui tu codigo
# Entropía de los nodos
diversity(gg3)
# Entropía de los nodos Shannon
mean(diversity(gg3))
?degree
# Centralidad de los nodos y comparación con métricas de grado y clustering
Degree <- degree(gg3)
Eig <- evcent(gg3)$vector
Closeness <- closeness(gg3)
Betweenness <- betweenness(g)
# Centralidad de los nodos y comparación con métricas de grado y clustering
Degree <- degree(gg3)
Eig <- evcent(gg3)$vector
Closeness <- closeness(gg3)
Betweenness <- betweenness(gg3)
centralities <- cbind(Degree, Eig, Closeness, Betweenness)
round(cor(centralities), 2)
mean(Eig)
#### infomap, fastgreedy, label propagation, walktrap
comms_infomap <- infomap.community(gg3)
comms_walktrap <- walktrap.community(gg3)
comms_infomap$membership
#### infomap, fastgreedy, label propagation, walktrap
# comms_infomap <- infomap.community(gg3)
# comms_walktrap <- walktrap.community(gg3)
modularity(comms_infomap)
modularity(comms_walktrap)
ll <- layout_with_lgl(gg3, maxiter=30)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
edge.arrow.size=0,
vertex.size=log(degree(g2)),
vertex.color=palcol[comms$membership])
ll <- layout_with_lgl(gg3, maxiter=30)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
edge.arrow.size=0,
vertex.size=log(degree(gg3)),
vertex.color=palcol[comms$membership])
ll <- layout_with_lgl(gg3, maxiter=30)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
edge.arrow.size=0,
vertex.size=log(degree(gg3)),
vertex.color=palcol[comms_infomap$membership])
ll <- layout_with_lgl(gg3, maxiter=30)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
vertex.size=log(degree(gg3)),
vertex.color=palcol[comms_infomap$membership])
?layout_with_lgl
ll <- layout_with_lgl(gg3)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
vertex.size=log(degree(gg3)),
vertex.color=palcol[comms_infomap$membership])
table(comms_infomap$membership)
summary(comms_infomap)
generate_sir <- function(N = 5, beta = 0.1, gamma = 0.1, graph){
graph <- set_vertex_attr(graph, 'label', value = 'S')
graph <- set_edge_attr(graph, 'label', value = '')
sample_index <- sample(1:vcount(graph), N)
graph <- set_vertex_attr(graph, 'label', index = sample_index, value = 'I')
n_contagiados = N
n_susceptibles = vcount(graph) - N
n_recuperados = 0
iteraciones_sin_contagios = 0
iteracion= 1
lista_contagiados = c(n_contagiados)
lista_susceptibles = c(n_susceptibles)
lista_recuperados = c(n_recuperados)
lista_nuevos_contagios = c(n_contagiados)
lista_grafo = list(graph)
while (iteraciones_sin_contagios < 3){
n_nuevos_contagios = 0
initial_graph <- graph
for (v in V(initial_graph)){
state <- V(initial_graph)[v]$label
if (state == 'I'){
if (rbinom(n=1, size=1, prob = gamma) == 1){
V(graph)[v]$label <- 'R'
n_recuperados = n_recuperados + 1
n_contagiados = n_contagiados - 1
}
}
if (state == 'S'){
for (neighbor in neighbors(graph, v)){
if ((V(initial_graph)[neighbor]$label == 'I') && (rbinom(n=1, size=1, prob = beta) == 1)){
V(graph)[v]$label <- 'I'
E(graph)[v %--% neighbor]$label <- 'I'
n_contagiados = n_contagiados + 1
n_nuevos_contagios = n_nuevos_contagios + 1
n_susceptibles = n_susceptibles - 1
break
}
}
}
}
if (n_nuevos_contagios == 0){
iteraciones_sin_contagios = iteraciones_sin_contagios + 1
} else {
iteraciones_sin_contagios = 0
}
iteracion = iteracion + 1
lista_contagiados = c(lista_contagiados, n_contagiados)
lista_susceptibles = c(lista_susceptibles, n_susceptibles)
lista_recuperados = c(lista_recuperados, n_recuperados)
lista_nuevos_contagios = c(lista_nuevos_contagios, n_nuevos_contagios)
lista_grafo[[iteracion]] = graph
}
return (list('contagiados' = lista_contagiados,
'susceptibles' = lista_susceptibles,
'recuperados' = lista_recuperados,
'nuevos_contagios' = lista_nuevos_contagios,
'iteraciones' = iteracion,
'grafos' = lista_grafo
))
}
plot_evolution <- function(evolution){
plot(1:evolution$iteraciones, evolution$contagiados,
type = 'l', col = 'red',
ylab = 'Nº Nodos', xlab = 'Iteraciones',
ylim = c(0, max(evolution$susceptibles)),
main = 'Evolución')
lines(1:evolution$iteraciones, evolution$recuperados,
type = 'l', col='green')
lines(1:evolution$iteraciones, evolution$susceptibles,
type = 'l', col='blue')
legend(evolution$iteraciones, max(evolution$susceptibles)/2,
legend=c('Contagiados', 'Recuperados', 'Susceptibles'),
col=c('red', 'green', 'blue'),
lty=1, cex=0.8, xjust = 1)
}
plot_new_infections <- function(list_new_infections, iteraciones){
plot(1:iteraciones, list_new_infections,
type = 'o', col = 'red', log = 'y',
ylab = 'Nº Nuevos Infectados', xlab = 'Iteraciones',
main = 'Nuevos infectados')
}
plot_infection_graph <- function(graph, index){
graph_colors <- ifelse(V(graph)$label == 'I', 'red',
ifelse(V(graph)$label == 'R', 'green', 'blue'))
subg <- subgraph.edges(graph, E(graph)[label == 'I'])
plot(subg,
layout = ll,
vertex.label = '',
vertex.size = log(degree(graph)),
edge.label = '',
vertex.color = graph_colors,
main = paste('Iteración', index))
}
create_gif <- function(list_graphs){
img <- magick::image_graph(width = 1000, height = 1000)
for (i in 1:length(list_graphs)){
plot_infection_graph(list_graphs[[i]], i)
}
dev.off()
animation <- magick::image_animate(img, fps = 2, optimize = TRUE)
print(animation)
}
knitr::opts_chunk$set(echo = T, warning=FALSE, message=FALSE)
library(igraph)
rm(list = ls())
setwd('C:/Users/Javier/Documents/masterAFI/18. Analisis de Grafos/01. Redes sociales/practica/')
dd <- read.csv('red_contactos.csv', sep = ';')
gg <- graph.data.frame(dd, directed = FALSE)
summary(gg)
vcount(gg)
ecount(gg)
gg2 <- simplify(gg, remove.multiple = TRUE, remove.loops = TRUE)
# para cada enlace, calculamos cuantos caminos cortos hay entre sus vértices
# el camino mínimo será igual al enlace, por lo tanto, la cantidad será igual al número de enlaces múltiples
# esta cantidad, lo añadimos como peso
E(gg2)$weight = sapply(E(gg2), function(e) {
length(all_shortest_paths(gg, from = ends(gg2, e)[1], to = ends(gg2, e)[2])$res) } )
summary(gg2)
hist(E(gg2)$weight, breaks = 30)
is.connected(gg2)
ccs <- components(gg2)
ccs$csize
id_compmayor <- which.max(ccs$csize)
vids <- ccs$membership == id_compmayor
vids <- which(ccs$membership == id_compmayor)
gg3 <- induced_subgraph(gg2, vids = vids )
summary(gg3)
mean(degree(gg3))
hist(degree(gg3), breaks = 20)
average.path.length(gg3)
diameter(gg3)
graph.density(gg3)
deg_dist <- degree_distribution(gg3)
fit <- fit_power_law(deg_dist)
fit
plot(deg_dist + 0.0001, log = 'xy', xlab = 'Node Degree', ylab = 'Probability')
lines(seq(deg_dist), seq(deg_dist)^-fit$alpha, col='red')
gg_prueba <- induced_subgraph(gg3, vids = V(gg3)[deg_dist > 0])
deg_dist_prueba <- degree_distribution(gg_prueba)
fit_prueba <- fit_power_law(deg_dist_prueba)
fit_prueba
plot(deg_dist_prueba  + 0.0001, log = 'xy', xlab = 'Node Degree', ylab = 'Probability')
lines(seq(deg_dist_prueba), seq(deg_dist_prueba)^-fit_prueba$alpha, col='red')
triangulos <- count_triangles(gg3)
mean(triangulos)
hist(triangulos, breaks = 30)
hist(diversity(gg3), breaks = 20, main = '', xlab = 'Diversity')
Degree <- degree(gg3)
Eig <- evcent(gg3)$vector
Closeness <- closeness(gg3)
Betweenness <- betweenness(gg3)
par(mfrow=c(2,2))
for (centrality in c('Degree', 'Eig', 'Closeness', 'Betweenness')){
hist(get(centrality), breaks = 30, xlab = centrality, main = '')
}
centralities <- cbind(Degree, Eig, Closeness, Betweenness, triangulos)
round(cor(centralities), 2)
comms_infomap <- infomap.community(gg3)
comms_walktrap <- walktrap.community(gg3)
modularity(comms_infomap)
modularity(comms_walktrap)
compare(comms_infomap, comms_walktrap, method='nmi')
table(comms_infomap$membership)
table(comms_walktrap$membership)
wws <- ifelse(crossing(comms_infomap, gg3), 1, 500)
ll <- layout_with_fr(gg3, weights=wws)
palcol <- rainbow(n=max(comms_infomap$membership))
plot(gg3,
layout = ll,
vertex.label='',
vertex.size=log(degree(gg3)),
vertex.color=palcol[comms_infomap$membership])
generate_sir <- function(N = 5, beta = 0.1, gamma = 0.1, graph){
graph <- set_vertex_attr(graph, 'label', value = 'S')
graph <- set_edge_attr(graph, 'label', value = '')
sample_index <- sample(1:vcount(graph), N)
graph <- set_vertex_attr(graph, 'label', index = sample_index, value = 'I')
n_contagiados = N
n_susceptibles = vcount(graph) - N
n_recuperados = 0
iteraciones_sin_contagios = 0
iteracion= 1
lista_contagiados = c(n_contagiados)
lista_susceptibles = c(n_susceptibles)
lista_recuperados = c(n_recuperados)
lista_nuevos_contagios = c(n_contagiados)
lista_grafo = list(graph)
while (iteraciones_sin_contagios < 3){
n_nuevos_contagios = 0
initial_graph <- graph
for (v in V(initial_graph)){
state <- V(initial_graph)[v]$label
if (state == 'I'){
if (rbinom(n=1, size=1, prob = gamma) == 1){
V(graph)[v]$label <- 'R'
n_recuperados = n_recuperados + 1
n_contagiados = n_contagiados - 1
}
}
if (state == 'S'){
for (neighbor in neighbors(graph, v)){
if ((V(initial_graph)[neighbor]$label == 'I') && (rbinom(n=1, size=1, prob = beta) == 1)){
V(graph)[v]$label <- 'I'
E(graph)[v %--% neighbor]$label <- 'I'
n_contagiados = n_contagiados + 1
n_nuevos_contagios = n_nuevos_contagios + 1
n_susceptibles = n_susceptibles - 1
break
}
}
}
}
if (n_nuevos_contagios == 0){
iteraciones_sin_contagios = iteraciones_sin_contagios + 1
} else {
iteraciones_sin_contagios = 0
}
iteracion = iteracion + 1
lista_contagiados = c(lista_contagiados, n_contagiados)
lista_susceptibles = c(lista_susceptibles, n_susceptibles)
lista_recuperados = c(lista_recuperados, n_recuperados)
lista_nuevos_contagios = c(lista_nuevos_contagios, n_nuevos_contagios)
lista_grafo[[iteracion]] = graph
}
return (list('contagiados' = lista_contagiados,
'susceptibles' = lista_susceptibles,
'recuperados' = lista_recuperados,
'nuevos_contagios' = lista_nuevos_contagios,
'iteraciones' = iteracion,
'grafos' = lista_grafo
))
}
plot_evolution <- function(evolution){
plot(1:evolution$iteraciones, evolution$contagiados,
type = 'l', col = 'red',
ylab = 'Nº Nodos', xlab = 'Iteraciones',
ylim = c(0, max(evolution$susceptibles)),
main = 'Evolución')
lines(1:evolution$iteraciones, evolution$recuperados,
type = 'l', col='green')
lines(1:evolution$iteraciones, evolution$susceptibles,
type = 'l', col='blue')
legend(evolution$iteraciones, max(evolution$susceptibles)/2,
legend=c('Contagiados', 'Recuperados', 'Susceptibles'),
col=c('red', 'green', 'blue'),
lty=1, cex=0.8, xjust = 1)
}
plot_new_infections <- function(list_new_infections, iteraciones){
plot(1:iteraciones, list_new_infections,
type = 'o', col = 'red', log = 'y',
ylab = 'Nº Nuevos Infectados', xlab = 'Iteraciones',
main = 'Nuevos infectados')
}
plot_infection_graph <- function(graph, index){
graph_colors <- ifelse(V(graph)$label == 'I', 'red',
ifelse(V(graph)$label == 'R', 'green', 'blue'))
subg <- subgraph.edges(graph, E(graph)[label == 'I'])
plot(subg,
layout = ll,
vertex.label = '',
vertex.size = log(degree(graph)),
edge.label = '',
vertex.color = graph_colors,
main = paste('Iteración', index))
}
create_gif <- function(list_graphs){
img <- magick::image_graph(width = 1000, height = 1000)
for (i in 1:length(list_graphs)){
plot_infection_graph(list_graphs[[i]], i)
}
dev.off()
animation <- magick::image_animate(img, fps = 2, optimize = TRUE)
print(animation)
}
ejemplo_prueba <- generate_sir(graph = gg3, beta = 0.8, gamma = 0.4, N = 20)
plot_evolution(ejemplo_prueba)
plot_new_infections(ejemplo_prueba$nuevos_contagios, ejemplo_prueba$iteraciones)
