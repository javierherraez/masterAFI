require("knitr")
library("caret")
library("dplyr")
opts_knit$set(root.dir = "C:/Proyectos/AFI/cursos_20212022/Regular")
# setwd("C:/Proyectos/AFI/cursos_20212022/Regular")
setwd("C:/Users/jherraez/Documents/masterAFI/09. Aprendizaje no supervisado/01. Clustering jerarquico y no jerarquico/")
####################
# Lectura de datos #
####################
datosBanca <- read.csv("Data/datosBanca.csv", header = TRUE, sep=",")
set.seed(1404)
datosBanca <- datosBanca[sample(nrow(datosBanca), nrow(datosBanca) * 0.8), ]
rownames(datosBanca) <- 1:nrow(datosBanca)
summary(datosBanca)
# Estandarización mediante discretización
# install.packages("nima")
library(nima)
datosBanca$checkingAccount_CAT <- discrete_by_quantile(datosBanca$checkingAccount)/4
datosBanca$deposit_CAT <- discrete_by_quantile(datosBanca$deposit)/4
datosBanca$shareOfStock_CAT <- discrete_by_quantile(datosBanca$shareOfStock)/4
datosBanca$pensionPlan_CAT <- discrete_by_quantile(datosBanca$pensionPlan)/4
#datosBanca$mortgage_CAT<-discrete_by_quantile(datosBanca$mortgage)/4
# Como da un error, la asignamos con IF
summary(datosBanca$mortgage)
datosBanca$mortgage_CAT <- datosBanca$mortgage
datosBanca$mortgage_CAT <- ifelse(datosBanca$mortgage <= 0, 1, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(0<datosBanca$mortgage & datosBanca$mortgage<= 45104, 2, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(45104<datosBanca$mortgage & datosBanca$mortgage<= 125979, 3, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- ifelse(125979<datosBanca$mortgage, 4, datosBanca$mortgage_CAT)
datosBanca$mortgage_CAT <- datosBanca$mortgage_CAT/4
summary(datosBanca$mortgage_CAT)
datosBanca$loan_CAT<-discrete_by_quantile(datosBanca$loan)/4
datosBanca$cards_CAT<-discrete_by_quantile(datosBanca$cards)/4
datosBanca$insurance_CAT<-discrete_by_quantile(datosBanca$insurance)/4
datosBanca$billPayment_CAT<-discrete_by_quantile(datosBanca$billPayment)/4
# La domiciliación de nómina es binaria y no es preciso estandarizarla
# Importante hacerla numérica porque si no, la considera integer y su AVERAGE vía SQL devuelve 0
datosBanca$salary_CAT<-as.numeric(datosBanca$salary)
summary(datosBanca)
# Cambiar missings por 0 #
datosBanca$checkingAccount_CAT[is.na(datosBanca$checkingAccount_CAT)]<-0
datosBanca$deposit_CAT[is.na(datosBanca$deposit_CAT)]<-0
datosBanca$shareOfStock_CAT[is.na(datosBanca$shareOfStock_CAT)]<-0
datosBanca$pensionPlan_CAT[is.na(datosBanca$pensionPlan_CAT)]<-0
datosBanca$mortgage_CAT[is.na(datosBanca$mortgage_CAT)]<-0
datosBanca$loan_CAT[is.na(datosBanca$loan_CAT)]<-0
datosBanca$cards_CAT[is.na(datosBanca$cards_CAT)]<-0
datosBanca$insurance_CAT[is.na(datosBanca$insurance_CAT)]<-0
datosBanca$billPayment_CAT[is.na(datosBanca$billPayment_CAT)]<-0
datosBanca.cat <- datosBanca %>%
select(ends_with('_CAT'))
library(cluster)
library(factoextra)
library(vegan)
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
matrizDistancias <- vegdist(datosBanca.cat, method = "euclidean")
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
matrizDistancias <- vegdist(datosBanca.cat.subset, method = "euclidean")
clusterJerarquico <- hclust(matrizDistancias, method="ward.D2")
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
library(dendextend)
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
rect.hclust(clusterJerarquico, k=2, border="red")
rect.hclust(clusterJerarquico, k=3, border="blue")
rect.hclust(clusterJerarquico, k=4, border="green")
rect.hclust(clusterJerarquico, k=5, border="yellow")
rect.hclust(clusterJerarquico, k=6, border="purple")
rect.hclust(clusterJerarquico, k=7, border="gray")
rect.hclust(clusterJerarquico, k=8, border="black")
datosBanca.cat.subset <- datosBanca.cat[sample(nrow(datosBanca.cat), nrow(datosBanca.cat) * 0.1), ]
rownames(datosBanca.cat.subset) <- 1:nrow(datosBanca.cat.subset)
matrizDistancias <- vegdist(datosBanca.cat.subset, method = "euclidean")
plot(as.dendrogram(clusterJerarquico),  main = "Dendrograma")
rect.hclust(clusterJerarquico, k=2, border="red")
rect.hclust(clusterJerarquico, k=3, border="blue")
rect.hclust(clusterJerarquico, k=4, border="green")
rect.hclust(clusterJerarquico, k=5, border="yellow")
rect.hclust(clusterJerarquico, k=6, border="purple")
rect.hclust(clusterJerarquico, k=7, border="gray")
rect.hclust(clusterJerarquico, k=8, border="black")
dend <- as.dendrogram(clusterJerarquico)
dend <- color_branches(dend, k=4)
plot(dend)
rm(list=ls())
library(tidyverse)
library(Hmisc)
library(corrplot)
library(effects)
setwd("masterAFI/10. Regresion Avanzada/javier_herraez_albarran_regresion_avanzada/")
booking <- read.csv("hotel_bookings.csv", header = TRUE)
str(booking)
summary(booking)
barplot(colSums(is.na(booking)), las=2)
booking[is.na(booking$children),]$children <- 0
booking <- booking %>% select(-arrival_date_year,
-arrival_date_week_number,
-arrival_date_day_of_month,
-meal,
-country,
-market_segment,
-distribution_channel,
-reserved_room_type,
-assigned_room_type,
-agent,
-company,
-days_in_waiting_list,
-reservation_status,
-reservation_status_date)
str(booking)
booking <- booking %>%
mutate(season = ifelse(arrival_date_month %in% c("December", "January", "February"), "Winter",
ifelse(arrival_date_month %in% c("March", "April", "May"), "Spring",
ifelse(arrival_date_month %in% c("June", "July", "August"), "Summer",
"Autumm")))) %>%
select(-arrival_date_month)
booking <- booking %>%
mutate(children = children + babies,
total_nights = stays_in_week_nights + stays_in_weekend_nights) %>%
select(-babies, -stays_in_week_nights, -stays_in_weekend_nights)
booking$hotel <- as.factor(booking$hotel)
booking$is_canceled <- as.factor(booking$is_canceled)
booking$is_repeated_guest <- as.factor(booking$is_repeated_guest)
booking$deposit_type <- as.factor(booking$deposit_type)
booking$customer_type <- as.factor(booking$customer_type)
booking$season <- as.factor(booking$season)
str(booking)
summary(booking)
hist.data.frame(booking)
table(booking$is_canceled)
booking %>%
ggplot(aes(x= customer_type, fill = is_canceled)) + geom_bar(position = "fill") +
labs(title = "Canceled by customer type", x = "", y = "", col = "")
booking %>%
ggplot(aes(x= customer_type, y = adults + children)) + geom_boxplot() +
labs(title = "People by customer type", x = "", y = "", col = "")
booking %>%
ggplot(aes(x= customer_type, y = adults + children)) + geom_boxplot() +
labs(title = "People by customer type", x = "", y = "", col = "") +
coord_cartesian(ylim=c(0,10))
booking %>%
ggplot(aes(x= deposit_type, fill = is_canceled)) + geom_bar() +
labs(title = "Canceled by customer type", x = "", y = "", col = "")
table(booking$deposit_type, booking$is_canceled)
booking <- booking %>% select(-deposit_type)
# la columna deposit_type 'Non Refund' y 'is_canceled' están correlacionadas de manera contraria a la intuición.
# Más del 99 % de las personas que pagaron el monto total por adelantado cancelaron.
booking %>%
ggplot(aes(x= is_canceled, y = adr, fill = is_canceled)) + geom_boxplot() +
labs(title = "ADR - is_cancelled", x = "", y = "", col = "")
booking %>%
ggplot(aes(x= is_canceled, y = adr, fill = is_canceled)) + geom_boxplot() +
labs(title = "ADR - is_cancelled", x = "", y = "", col = "") +  coord_cartesian(ylim=c(0,600))
booking %>%
ggplot(aes(x= is_canceled, y = total_nights, fill = is_canceled)) + geom_boxplot() +
labs(title = "Nights - is_cancelled", x = "", y = "", col = "")
booking %>%
ggplot(aes(x= season, fill = is_canceled)) + geom_bar() +
labs(title = "Canceled by Season", x = "", y = "", col = "")
numeric_columns <- unlist(lapply(booking, is.numeric))
numeric_columns <- booking[, numeric_columns]
corrplot(cor(numeric_columns), method='number')
partition <- sort(sample(nrow(booking), nrow(booking)*.7))
booking.train <- booking[partition,]
booking.test <- booking[-partition,]
booking.mod <- glm(is_canceled ~ ., family=binomial(link="logit"), data=booking.train)
summary(booking.mod)
booking.mod <- glm(is_canceled ~ ., family=binomial(link="logit"), data=booking.train)
plot(booking$is_canceled, predict(fit.poisson, type = "response"))
plot(booking$is_canceled, predict(booking.mod, type = "response"))
